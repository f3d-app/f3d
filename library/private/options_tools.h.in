#ifndef f3d_options_tools_h
#define f3d_options_tools_h

#include "options.h"
#include "types.h"

#include <sstream>

#include <variant>

namespace f3d
{
// Required as this becomes an internal type when CXX17 is not exposed byt the libf3d API
using option_variant_t = std::variant<bool, int, double, std::string, std::vector<double>>;

namespace options_tools
{

// TODO expose parse methods in options API ?
//----------------------------------------------------------------------------
/**
 * Parse provided string into provided boolean reference
 * Numerical and boolaplha are both supported
 */
static void parse(const std::string& str, bool& value)
{
  // TODO implement proper parsing, eg "True", "TRUE", "ON", "On", ...
  bool b1;
  bool b2;
  std::istringstream(str) >> b1;
  std::istringstream(str) >> std::boolalpha >> b2;
  value = b1 || b2;
}

//----------------------------------------------------------------------------
/**
 * Parse provided string into provided int reference
 * Rely on std::stoi for parsing
 * Can throw options::parsing_exception in case of failure to parse
 */
static void parse(const std::string& str, int& value)
{
  // TODO implement more parsing possibilities ?
  try
  {
    value = std::stoi(str);
  }
  catch (std::invalid_argument const&)
  {
    throw options::parsing_exception("Cannot parse " + str + " into an int");
  }
  catch (std::out_of_range const&)
  {
    throw options::parsing_exception(
      "Cannot parse " + str + " into an int as it would go out of range");
  }
}

//----------------------------------------------------------------------------
/**
 * Parse provided string into provided double reference
 * Rely on std::stod for parsing
 * Can throw options::parsing_exception in case of failure to parse
 */
static void parse(const std::string& str, double& value)
{
  // TODO implement more parsing possibilities ?
  try
  {
    value = std::stod(str);
  }
  catch (std::invalid_argument const&)
  {
    throw options::parsing_exception("Cannot parse " + str + " into a double");
  }
  catch (std::out_of_range const&)
  {
    throw options::parsing_exception(
      "Cannot parse " + str + " into a double as it would go out of range");
  }
}

//----------------------------------------------------------------------------
/**
 * Parse provided string into provided ratio_t reference
 * Rely on parse(string, double&) for parsing
 * Can throw options::parsing_exception in case of failure to parse
 */
static void parse(const std::string& str, ratio_t& value)
{
  // TODO implement proper ratio parsing
  double dbl;
  options_tools::parse(str, dbl);
  value = dbl;
}

/**
 * Parse (copy) provided string into provided string reference
 */
//----------------------------------------------------------------------------
static void parse(const std::string& str, std::string& value)
{
  value = str;
}

//----------------------------------------------------------------------------
/**
 * Parse provided string into provided double vector reference
 * Split the string using ',', then rely on parse(string, double&) for parsing each token
 * Can throw options::parsing_exception in case of failure to parse
 */
static void parse(const std::string& str, std::vector<double>& value)
{
  // TODO implement more parsing possibilities, eg different types of tokens
  std::istringstream split(str);
  value.clear();
  for (std::string each; std::getline(split, each, ',');)
  {
    double dbl;
    options_tools::parse(each, dbl);
    value.push_back(dbl);
  }
}

// TODO Improve string generation
//----------------------------------------------------------------------------
/**
 * Generate a string from provided boolean
 * using boolalpha formatting, eg: "true" or "false"
 */
static std::string toString(const bool& var)
{
  std::stringstream stream;
  stream << std::boolalpha << var;
  return stream.str();
}

//----------------------------------------------------------------------------
/**
 * Generate a string from provided double
 * using ostringstream with std::noshowpoint
 */
static std::string toString(const double& var)
{
  std::ostringstream stream;
  stream << std::noshowpoint << var;
  return stream.str();
}

//----------------------------------------------------------------------------
/**
 * Generate a string from provided ratio_t
 * rely on toString(double&)
 */
static std::string toString(const ratio_t& var)
{
  // TODO generate a proper ratio string
  double val = var;
  return options_tools::toString(val);
}

//----------------------------------------------------------------------------
/**
 * Generate (returns) a string from provided string
 */
static std::string toString(const std::string& var)
{
  return var;
}

//----------------------------------------------------------------------------
/**
 * Generate a string from provided double vector
 * rely on toString(double&) and add `, ` between the double values
 */
static std::string toString(const std::vector<double>& var)
{
  std::ostringstream stream;
  unsigned int i = 0;
  for (auto& elem : var)
  {
    stream << ((i > 0) ? ", " : "") << options_tools::toString(elem);
    i++;
  }
  return stream.str();
}

//----------------------------------------------------------------------------
/**
 * Generic templated string generation from provided value
 * rely on std::to_string
 */
template<typename T>
static std::string toString(const T& var)
{
  return std::to_string(var);
}

//----------------------------------------------------------------------------
/**
 * Generated method that set an option in provided options according to
 * a provided name and value.
 * Can throw options::inexistent_exception or options::incompatible_exception
 */
void set(options& opt, const std::string& name, const option_variant_t& value)
{
  try
  {
    ${_options_setter};
    else throw options::inexistent_exception("Option " + name + " does not exist");
  }
  catch (const std::bad_variant_access&)
  {
    throw options::incompatible_exception("Trying to set " + name + " with incompatible type");
  }
}

//----------------------------------------------------------------------------
/**
 * Generated method that get an option value in
 * provided options using a provided name
 * Can throw options::inexistent_exception
 */
option_variant_t get(const options& opt, const std::string& name)
{
  option_variant_t var;
  ${_options_getter};
  else throw options::inexistent_exception("Option " + name + " does not exist");
  return var;
}

//----------------------------------------------------------------------------
/**
 * Generated method to recover all option names
 */
std::vector<std::string> getNames()
{
  std::vector<std::string> vec{ ${_options_lister} };
  return vec;
}

//----------------------------------------------------------------------------
/**
 * See options::setAsString
 */
void setAsString(options& opt, const std::string& name, const std::string& str)
{
  ${_options_string_setter};
  else throw options::inexistent_exception("Option " + name + " does not exist");
}
//----------------------------------------------------------------------------
/**
 * See options::getAsString
 */
std::string getAsString(const options& opt, const std::string& name)
{
  ${_options_string_getter};
  else throw options::inexistent_exception("Option " + name + " does not exist");
}
} // option_tools
} // f3d
#endif // f3d_options_tools_h
