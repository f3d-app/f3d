#ifndef f3d_options_tools_h
#define f3d_options_tools_h

#include "options.h"
#include "types.h"

#include <sstream>

namespace f3d
{
namespace options_tools
{

// TODO expose parse methods in options API ?
//----------------------------------------------------------------------------
static void parse(const std::string& str, bool& value)
{
  // TODO implement proper parsing
  bool b1;
  bool b2;
  std::istringstream(str) >> b1;
  std::istringstream(str) >> std::boolalpha >> b2;
  value = b1 || b2;
}

//----------------------------------------------------------------------------
static void parse(const std::string& str, int& value)
{
  // TODO implement proper parsing
  try
  {
    value = std::stoi(str);
  }
  catch (std::invalid_argument const&)
  {
    throw options::parsing_exception("Cannot parse " + str + " into an int");
  }
  catch (std::out_of_range const&)
  {
    throw options::parsing_exception(
      "Cannot parse " + str + " into an int as it would go out of range");
  }
}

//----------------------------------------------------------------------------
static void parse(const std::string& str, double& value)
{
  // TODO implement proper parsing
  try
  {
    value = std::stod(str);
  }
  catch (std::invalid_argument const&)
  {
    throw options::parsing_exception("Cannot parse " + str + " into a double");
  }
  catch (std::out_of_range const&)
  {
    throw options::parsing_exception(
      "Cannot parse " + str + " into a double as it would go out of range");
  }
}

//----------------------------------------------------------------------------
static void parse(const std::string& str, ratio_t& value)
{
  double dbl;
  options_tools::parse(str, dbl);
  value = dbl;
}

//----------------------------------------------------------------------------
static void parse(const std::string& str, std::string& value)
{
  value = str;
}

//----------------------------------------------------------------------------
static void parse(const std::string& str, std::vector<double>& value)
{
  // TODO implement proper parsing
  std::istringstream split(str);
  value.clear();
  for (std::string each; std::getline(split, each, ',');)
  {
    double dbl;
    options_tools::parse(each, dbl);
    value.push_back(dbl);
  }
}

//----------------------------------------------------------------------------
template<typename T>
static void parse(const std::string& str, T& value, option_types)
{
  options_tools::parse(str, value);
}

//----------------------------------------------------------------------------
static void parse(const std::string& str, double& value, option_types type)
{
  if (type == option_types::_ratio)
  {
    ratio_t ratio;
    options_tools::parse(str, ratio);
    value = ratio;
  }
  else
  {
    options_tools::parse(str, value);
  }
}

// TODO Improve string generation
//----------------------------------------------------------------------------
static std::string toString(const bool& var)
{
  std::stringstream stream;
  stream << std::boolalpha << var;
  return stream.str();
}

//----------------------------------------------------------------------------
static std::string toString(const double& var)
{
  std::ostringstream stream;
  stream << std::noshowpoint << var;
  return stream.str();
}

//----------------------------------------------------------------------------
static std::string toString(const ratio_t& var)
{
  double val = var;
  return options_tools::toString(val);
}

//----------------------------------------------------------------------------
static std::string toString(const std::string& var)
{
  return var;
}

//----------------------------------------------------------------------------
static std::string toString(const std::vector<double>& var)
{
  std::ostringstream stream;
  unsigned int i = 0;
  for (auto& elem : var)
  {
    stream << ((i > 0) ? ", " : "") << options_tools::toString(elem);
    i++;
  }
  return stream.str();
}

//----------------------------------------------------------------------------
template<typename T>
static std::string toString(const T& var)
{
  return std::to_string(var);
}

//----------------------------------------------------------------------------
template<typename T>
static std::string toString(const T& value, option_types)
{
  return options_tools::toString(value);
}

//----------------------------------------------------------------------------
static std::string toString(const double& value, option_types type)
{
  if (type == option_types::_ratio)
  {
    ratio_t ratio = value;
    return options_tools::toString(ratio);
  }
  else
  {
    return options_tools::toString(value);
  }
}

//----------------------------------------------------------------------------
void set(options& opt, const std::string& name, const option_variant_t& value)
{
  try
  {
    ${_options_setter};
    else throw options::inexistent_exception("Option " + name + " does not exist");
  }
  catch (const std::bad_variant_access&)
  {
    throw options::incompatible_exception("Trying to set " + name + " with incompatible type");
  }
}

//----------------------------------------------------------------------------
option_variant_t get(const options& opt, const std::string& name)
{
  option_variant_t var;
  ${_options_getter};
  else throw options::inexistent_exception("Option " + name + " does not exist");
  return var;
}

//----------------------------------------------------------------------------
option_types getType(const std::string& name)
{
  ${_options_typer};
  else throw options::inexistent_exception("Option " + name + " does not exist");
  // Cannot be reached
  return option_types::_bool;
}

//----------------------------------------------------------------------------
std::vector<std::string> getNames()
{
  std::vector<std::string> vec{ ${_options_lister} };
  return vec;
}

//----------------------------------------------------------------------------
void setAsString(options& opt, const std::string& name, const std::string& str)
{
  option_types type = options_tools::getType(name);
  option_variant_t var = options_tools::get(opt, name);
  std::visit([str, type](auto& ref) { options_tools::parse(str, ref, type); }, var);
  options_tools::set(opt, name, var);
}

//----------------------------------------------------------------------------
std::string getAsString(const options& opt, const std::string& name)
{
  option_types type = options_tools::getType(name);
  option_variant_t var = options_tools::get(opt, name);
  return std::visit([type](const auto& ref) { return options_tools::toString(ref, type); }, var);
}
}
}
#endif
