#ifndef f3d_options_tools_h
#define f3d_options_tools_h

#include "options.h"
#include "types.h"

#include <algorithm>
#include <sstream>

namespace f3d
{
namespace options_tools
{

//----------------------------------------------------------------------------
/**
 * A std::string_view trim function
 */
std::string trim(std::string_view strv)
{
  constexpr std::string_view spaces = " \t\r\v\n";
  strv.remove_prefix(std::min(strv.find_first_not_of(spaces), strv.size()));
  strv.remove_suffix(std::min(strv.size() - strv.find_last_not_of(spaces) - 1, strv.size()));
  return std::string(strv);
}

//----------------------------------------------------------------------------
/** Call `std::stod` and throw `std::invalid_argument` if the whole string has not been consumed. */
double stodStrict(const std::string& str)
{
  std::size_t pos = 0;
  const double parsed = std::stod(str, &pos);
  if (pos != str.size())
  {
    throw std::invalid_argument("partial");
  }
  return parsed;
}

//----------------------------------------------------------------------------
/** Call `std::stoi` and throw `std::invalid_argument` if the whole string has not been consumed */
int stoiStrict(const std::string& str)
{
  std::size_t pos = 0;
  const int parsed = std::stoi(str, &pos);
  if (pos != str.size())
  {
    throw std::invalid_argument("partial");
  }
  return parsed;
}

//----------------------------------------------------------------------------
/**
 * Vector specific templated parse method.
 * Splits on `","` and trims chunks before parsing each element
 */
template<typename T>
struct is_vector : std::false_type
{
};
template<typename... Args>
struct is_vector<std::vector<Args...>> : std::true_type
{
};
template<typename T>
T parse(const std::string& str)
{
  static_assert(is_vector<T>::value, "non-vector types parsing must be specialized");

  // TODO implement more parsing possibilities, eg different types of tokens
  T vec;
  std::istringstream split(str);
  for (std::string each; std::getline(split, each, ',');)
  {
    vec.emplace_back(options_tools::parse<typename T::value_type>(options_tools::trim(each)));
  }
  return vec;
}

//----------------------------------------------------------------------------
/**
 * Parse provided string into a bool. Supports boolapha values as well as "yes/no" and "on/off"
 */
template<>
bool parse(const std::string& str)
{
  std::string s = str;
  std::transform(s.begin(), s.end(), s.begin(), [](unsigned char c) { return std::tolower(c); });
  if (s == "true" || s == "yes" || s == "on" || s == "1")
  {
    return true;
  }
  if (s == "false" || s == "no" || s == "off" || s == "0")
  {
    return false;
  }
  throw options::parsing_exception("Cannot parse " + str + " into a bool");
}

//----------------------------------------------------------------------------
/**
 * Parse provided string into an int
 * Rely on std::stoi for parsing
 * Can throw options::parsing_exception in case of failure to parse
 */
template<>
int parse(const std::string& str)
{
  try
  {
    return stoiStrict(str);
  }
  catch (std::invalid_argument const&)
  {
    throw options::parsing_exception("Cannot parse " + str + " into an int");
  }
  catch (std::out_of_range const&)
  {
    throw options::parsing_exception(
      "Cannot parse " + str + " into an int as it would go out of range");
  }
}

//----------------------------------------------------------------------------
/**
 * Parse provided string into a double
 * Rely on std::stod for parsing
 * Can throw options::parsing_exception in case of failure to parse
 */
template<>
double parse(const std::string& str)
{
  try
  {
    return stodStrict(str);
  }
  catch (std::invalid_argument const&)
  {
    throw options::parsing_exception("Cannot parse " + str + " into a double");
  }
  catch (std::out_of_range const&)
  {
    throw options::parsing_exception(
      "Cannot parse " + str + " into a double as it would go out of range");
  }
}

//----------------------------------------------------------------------------
/**
 * Parse provided string into a ratio_t.
 * Supported formats: number (same as `<double>` version), percentage, fraction
 * Can throw options::parsing_exception in case of failure to parse
 */
template<>
ratio_t parse(const std::string& str)
{
  try
  {
    if (!str.empty() && str.at(str.size() - 1) == '%')
    {
      return stodStrict(str.substr(0, str.size() - 1)) / 100;
    }

    const std::size_t i = str.find('/');
    if (i != std::string::npos)
    {
      return stodStrict(str.substr(0, i)) / stodStrict(str.substr(i + 1, str.size() - i - 1));
    }

    return stodStrict(str);
  }
  catch (std::invalid_argument const&)
  {
    throw options::parsing_exception("Cannot parse " + str + " into a ratio_t");
  }
  catch (std::out_of_range const&)
  {
    throw options::parsing_exception(
      "Cannot parse " + str + " into a ratio_t as it would go out of range");
  }
}

//----------------------------------------------------------------------------
/**
 * Return provided string stripped of leading and trailing spaces.
 */
template<>
std::string parse(const std::string& str)
{
  return options_tools::trim(str);
}

// TODO Improve string generation
//----------------------------------------------------------------------------
/**
 * Generic templated string generation from provided value
 * rely on std::to_string
 */
template<typename T>
std::string format(const T& var)
{
  return std::to_string(var);
}

//----------------------------------------------------------------------------
/**
 * Format provided var into a string from provided boolean
 * using boolalpha formatting, eg: "true" or "false"
 */
template<>
std::string format(const bool& var)
{
  std::stringstream stream;
  stream << std::boolalpha << var;
  return stream.str();
}

//----------------------------------------------------------------------------
/**
 * Format provided var into a string from provided double
 * using ostringstream with std::noshowpoint
 */
template<>
std::string format(const double& var)
{
  std::ostringstream stream;
  stream << std::noshowpoint << var;
  return stream.str();
}

//----------------------------------------------------------------------------
/**
 * Format provided var into a string from provided ratio_t
 * rely on format(double&)
 */
template<>
std::string format(const ratio_t& var)
{
  // TODO generate a proper ratio string
  double val = var;
  return options_tools::format(val);
}

//----------------------------------------------------------------------------
/**
 * Generate (returns) a string from provided string
 */
template<>
std::string format(const std::string& var)
{
  return var;
}

//----------------------------------------------------------------------------
/**
 * Format provided var into a string from provided double vector
 * rely on format(double&) and add `, ` between the double values
 */
template<>
std::string format(const std::vector<double>& var)
{
  std::ostringstream stream;
  unsigned int i = 0;
  for (auto& elem : var)
  {
    stream << ((i > 0) ? ", " : "") << options_tools::format(elem);
    i++;
  }
  return stream.str();
}

//----------------------------------------------------------------------------
/**
 * Generated method, see `options::set`
 */
void set(options& opt, const std::string& name, const option_variant_t& value)
{
  try
  {
    // clang-format off
    ${_options_setter};
    // clang-format on
    else throw options::inexistent_exception("Option " + name + " does not exist");
  }
  catch (const std::bad_variant_access&)
  {
    throw options::incompatible_exception("Trying to set " + name + " with incompatible type");
  }
}

//----------------------------------------------------------------------------
/**
 * Generated method, see `options::get`
 */
option_variant_t get(const options& opt, const std::string& name)
{
  try
  {
    // clang-format off
    ${_options_getter};
    // clang-format on
    else throw options::inexistent_exception("Option " + name + " does not exist");
  }
  catch (const std::bad_optional_access&)
  {
    throw options::no_value_exception("Trying to get " + name + " before it was set");
  }
}

//----------------------------------------------------------------------------
/**
 * Generated method, see `options::getNames`
 */
std::vector<std::string> getNames()
{
  // clang-format off
  return { ${_options_lister} };
  // clang-format on
}

//----------------------------------------------------------------------------
/**
 * Generated method, see `options::setAsString`
 */
void setAsString(options& opt, const std::string& name, const std::string& str)
{
  // clang-format off
  ${_options_string_setter};
  // clang-format on
  else throw options::inexistent_exception("Option " + name + " does not exist");
}
//----------------------------------------------------------------------------
/**
 * Generated method, see `options::getAsString`
 */
std::string getAsString(const options& opt, const std::string& name)
{
  try
  {
    // clang-format off
    ${_options_string_getter};
    // clang-format on
    else throw options::inexistent_exception("Option " + name + " does not exist");
  }
  catch (const std::bad_optional_access&)
  {
    throw options::no_value_exception("Trying to get " + name + " before it was set");
  }
}

//----------------------------------------------------------------------------
/**
 * Generated method, see `options::isOptional`
 */
bool isOptional(const std::string& name)
{
  // clang-format off
  ${_options_is_optional};
  // clang-format on
  else throw options::inexistent_exception("Option " + name + " does not exist");
}

//----------------------------------------------------------------------------
/**
 * Generated method, see `options::reset`
 */
void reset(options& opt, const std::string& name)
{
  // clang-format off
  ${_options_reset};
  // clang-format on
  else throw options::inexistent_exception("Option " + name + " does not exist");
}

} // option_tools
} // f3d
#endif // f3d_options_tools_h
