#ifndef f3d_options_tools_h
#define f3d_options_tools_h

#include "options.h"
#include "types.h"

#include <sstream>

#ifndef F3D_ENABLE_CXX17_API
#include <variant>
#endif

namespace f3d
{
// Required as this becomes an internal type when CXX17 is not exposed byt the libf3d API
#ifndef F3D_ENABLE_CXX17_API
using option_variant_t = std::variant<bool, int, double, std::string, std::vector<double>>;
#endif

namespace options_tools
{

// TODO expose parse methods in options API ?
//----------------------------------------------------------------------------
/**
 * Parse provided string into provided boolean reference
 * Numerical and boolaplha are both supported
 */
static void parse(const std::string& str, bool& value)
{
  // TODO implement proper parsing, eg "True", "TRUE", "ON", "On", ...
  bool b1;
  bool b2;
  std::istringstream(str) >> b1;
  std::istringstream(str) >> std::boolalpha >> b2;
  value = b1 || b2;
}

//----------------------------------------------------------------------------
/**
 * Parse provided string into provided int reference
 * Rely on std::stoi for parsing
 * Can throw options::parsing_exception in case of failure to parse
 */
static void parse(const std::string& str, int& value)
{
  // TODO implement more parsing possibilities ?
  try
  {
    value = std::stoi(str);
  }
  catch (std::invalid_argument const&)
  {
    throw options::parsing_exception("Cannot parse " + str + " into an int");
  }
  catch (std::out_of_range const&)
  {
    throw options::parsing_exception(
      "Cannot parse " + str + " into an int as it would go out of range");
  }
}

//----------------------------------------------------------------------------
/**
 * Parse provided string into provided double reference
 * Rely on std::stod for parsing
 * Can throw options::parsing_exception in case of failure to parse
 */
static void parse(const std::string& str, double& value)
{
  // TODO implement more parsing possibilities ?
  try
  {
    value = std::stod(str);
  }
  catch (std::invalid_argument const&)
  {
    throw options::parsing_exception("Cannot parse " + str + " into a double");
  }
  catch (std::out_of_range const&)
  {
    throw options::parsing_exception(
      "Cannot parse " + str + " into a double as it would go out of range");
  }
}

//----------------------------------------------------------------------------
/**
 * Parse provided string into provided ratio_t reference
 * Rely on parse(string, double&) for parsing
 * Can throw options::parsing_exception in case of failure to parse
 */
static void parse(const std::string& str, ratio_t& value)
{
  // TODO implement proper ratio parsing
  double dbl;
  options_tools::parse(str, dbl);
  value = dbl;
}

/**
 * Parse (copy) provided string into provided string reference
 */
//----------------------------------------------------------------------------
static void parse(const std::string& str, std::string& value)
{
  value = str;
}

//----------------------------------------------------------------------------
/**
 * Parse provided string into provided double vector reference
 * Split the string using ',', then rely on parse(string, double&) for parsing each token
 * Can throw options::parsing_exception in case of failure to parse
 */
static void parse(const std::string& str, std::vector<double>& value)
{
  // TODO implement more parsing possibilities, eg different types of tokens
  std::istringstream split(str);
  value.clear();
  for (std::string each; std::getline(split, each, ',');)
  {
    double dbl;
    options_tools::parse(each, dbl);
    value.push_back(dbl);
  }
}

//----------------------------------------------------------------------------
/**
 * Generic parsing templated method, parse provided string into provided reference
 * option_types is ignored.
 */
template<typename T>
static void parse(const std::string& str, T& value, option_types)
{
  options_tools::parse(str, value);
}

//----------------------------------------------------------------------------
/**
 * Specific parsing method used to distinguish between ratio_t and double parsing
 * Parse provided string into provided double reference with the correct parsing method
 * depending on the provided option_types
 */
static void parse(const std::string& str, double& value, option_types type)
{
  if (type == option_types::_ratio)
  {
    ratio_t ratio;
    options_tools::parse(str, ratio);
    value = ratio;
  }
  else
  {
    options_tools::parse(str, value);
  }
}

// TODO Improve string generation
//----------------------------------------------------------------------------
/**
 * Generate a string from provided boolean
 * using boolalpha formating, eg: "true" or "false"
 */
static std::string toString(const bool& var)
{
  std::stringstream stream;
  stream << std::boolalpha << var;
  return stream.str();
}

//----------------------------------------------------------------------------
/**
 * Generate a string from provided double
 * using ostringstream with std::noshowpoint
 */
static std::string toString(const double& var)
{
  std::ostringstream stream;
  stream << std::noshowpoint << var;
  return stream.str();
}

//----------------------------------------------------------------------------
/**
 * Generate a string from provided ratio_t
 * rely on toString(double&)
 */
static std::string toString(const ratio_t& var)
{
  // TODO generate a proper ratio string
  double val = var;
  return options_tools::toString(val);
}

//----------------------------------------------------------------------------
/**
 * Generate (returns) a string from provided string
 */
static std::string toString(const std::string& var)
{
  return var;
}

//----------------------------------------------------------------------------
/**
 * Generate a string from provided double vector
 * rely on toString(double&) and add `, ` between the double values
 */
static std::string toString(const std::vector<double>& var)
{
  std::ostringstream stream;
  unsigned int i = 0;
  for (auto& elem : var)
  {
    stream << ((i > 0) ? ", " : "") << options_tools::toString(elem);
    i++;
  }
  return stream.str();
}

//----------------------------------------------------------------------------
/**
 * Generic templated string generation from provided value
 * rely on std::to_string
 */
template<typename T>
static std::string toString(const T& var)
{
  return std::to_string(var);
}

//----------------------------------------------------------------------------
/**
 * Generic templated string generation from provided value with an option_types
 * rely on options_tools::toString and ignore option_types
 */
template<typename T>
static std::string toString(const T& value, option_types)
{
  return options_tools::toString(value);
}

//----------------------------------------------------------------------------
/**
 * Specific string generation from provided double value with an option_types
 * rely on options_tools::toString and uses option_types to distinguish between
 * double and ratio_t
 */
static std::string toString(const double& value, option_types type)
{
  if (type == option_types::_ratio)
  {
    ratio_t ratio = value;
    return options_tools::toString(ratio);
  }
  else
  {
    return options_tools::toString(value);
  }
}

//----------------------------------------------------------------------------
/**
 * Generated method that set an option in provided options according to
 * a provided name and value.
 * Can throw options::inexistent_exception or options::incompatible_exception
 */
void set(options& opt, const std::string& name, const option_variant_t& value)
{
  try
  {
    ${_options_setter};
    else throw options::inexistent_exception("Option " + name + " does not exist");
  }
  catch (const std::bad_variant_access&)
  {
    throw options::incompatible_exception("Trying to set " + name + " with incompatible type");
  }
}

//----------------------------------------------------------------------------
/**
 * Generated method that get an option value in
 * provided options using a provided name
 * Can throw options::inexistent_exception
 */
option_variant_t get(const options& opt, const std::string& name)
{
  option_variant_t var;
  ${_options_getter};
  else throw options::inexistent_exception("Option " + name + " does not exist");
  return var;
}

//----------------------------------------------------------------------------
/**
 * Generated method that get an option type using a provided name
 * Can throw options::inexistent_exception
 */
option_types getType(const std::string& name)
{
  ${_options_typer};
  else throw options::inexistent_exception("Option " + name + " does not exist");
  // Cannot be reached
  return option_types::_bool;
}

//----------------------------------------------------------------------------
/**
 * Generated method to recover all option names
 */
std::vector<std::string> getNames()
{
  std::vector<std::string> vec{ ${_options_lister} };
  return vec;
}

//----------------------------------------------------------------------------
/**
 * See options::setAsString
 */
void setAsString(options& opt, const std::string& name, const std::string& str)
{
  option_types type = options_tools::getType(name);
  option_variant_t var = options_tools::get(opt, name);
  std::visit([str, type](auto& ref) { options_tools::parse(str, ref, type); }, var);
  options_tools::set(opt, name, var);
}

//----------------------------------------------------------------------------
/**
 * See options::getAsString
 */
std::string getAsString(const options& opt, const std::string& name)
{
  option_types type = options_tools::getType(name);
  option_variant_t var = options_tools::get(opt, name);
  return std::visit([type](const auto& ref) { return options_tools::toString(ref, type); }, var);
}
} // option_tools
} // f3d
#endif // f3d_options_tools_h
